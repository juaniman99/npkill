'use strict';

import { Dir, Dirent, opendir } from 'fs';

import EventEmitter from 'events';
import { WorkerStats } from './files.worker.service';
import { basename } from 'path';
import { parentPort } from 'worker_threads';
import { IListDirParams } from 'src/interfaces';

enum ETaskOperation {
  'explore',
  'getSize',
}
interface Task {
  operation: ETaskOperation;
  path: string;
}

(() => {
  let id = 0;
  let fileWalker: FileWalker = null;
  let tunnel; //: MessagePort;

  parentPort.postMessage({
    type: 'alive',
    value: null,
  });

  parentPort.on('message', (data) => {
    if (data?.type === 'startup') {
      id = data.value.id;
      tunnel = data.value.channel;
      fileWalker = new FileWalker();
      initTunnelListeners();
      initFileWalkerListeners();
    }
  });

  function initTunnelListeners() {
    tunnel.on('message', (data) => {
      if (data?.type === 'explore-config') {
        fileWalker.setSearchConfig(data.value);
      }

      if (data?.type === 'explore') {
        fileWalker.enqueueTask(data.value.path);
      }
    });
  }

  function initFileWalkerListeners() {
    fileWalker.events.on('onResult', ({ results }) => {
      tunnel.postMessage({
        type: 'scan-result',
        value: { results, workerId: id, pending: fileWalker.pendingJobs },
      });
    });

    fileWalker.events.on('onCompleted', () => {
      tunnel.postMessage({ type: 'scan-job-completed' });
    });

    fileWalker.events.on('onStats', (stats: WorkerStats) => {
      tunnel.postMessage({ type: 'stats', value: stats });
    });
  }
})();

class FileWalker {
  readonly events = new EventEmitter();
  private searchConfig: IListDirParams = {
    path: '',
    target: '',
  };
  private taskQueue: Task[] = [];
  private completedTasks = 0;
  private procs = 0;
  // More PROCS improve the speed of the search, but increment
  // but it will greatly increase the maximum ram usage.
  private readonly MAX_PROCS = 100;

  setSearchConfig(params: IListDirParams) {
    this.searchConfig = params;
  }

  enqueueTask(path: string) {
    this.taskQueue.push({ path, operation: ETaskOperation.explore });
    this.processQueue();
  }

  private run(path: string) {
    this.updateProcs(1);

    opendir(path, async (err, dir: Dir) => {
      if (err) {
        // Should notify important errors
        this.completeTask();
        return;
      }

      this.analizeDir(path, dir);
    });
  }

  private async analizeDir(path: string, dir: Dir) {
    const results = [];
    let entry: Dirent | null = null;
    while ((entry = await dir.read().catch(() => null)) != null) {
      this.newDirEntry(path, entry, results);
    }

    this.events.emit('onResult', { results: results });

    await dir.close();
    this.completeTask();

    if (this.taskQueue.length === 0 && this.procs === 0) {
      this.completeAll();
    }
  }

  private newDirEntry(path: string, entry: Dirent, results: any[]) {
    const subpath = (path === '/' ? '' : path) + '/' + entry.name;
    const shouldSkip = !entry.isDirectory() || this.isExcluded(subpath);
    if (shouldSkip) {
      return;
    }

    results.push({
      path: subpath,
      isTarget: this.isTargetFolder(entry.name),
    });
  }

  private isExcluded(path: string) {
    return basename(path) === '.git';
  }

  private isTargetFolder(path: string): boolean {
    // return basename(path) === this.searchConfig.target;
    return path === this.searchConfig.target;
  }

  private completeTask() {
    this.updateProcs(-1);
    this.processQueue();
    this.completedTasks++;
  }

  private updateProcs(value: number) {
    this.procs += value;
  }

  private processQueue() {
    while (this.procs < this.MAX_PROCS && this.taskQueue.length > 0) {
      const path = this.taskQueue.shift().path;
      this.run(path);
    }
  }

  private completeAll() {
    this.events.emit('onStats');
    this.events.emit('onCompleted');
  }

  get stats(): WorkerStats {
    return {
      pendingSearchTasks: this.taskQueue.length,
      completedSearchTasks: this.completedTasks,
      procs: this.procs,
    };
  }

  get pendingJobs() {
    return this.taskQueue.length;
  }
}
